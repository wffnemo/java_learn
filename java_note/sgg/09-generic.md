# 泛型

## 一、泛型概述

* JDK1.5前，Java集合被设计成能保存任何类型的对象，只要求具有很好的通用性，但是这样会带来两个问题：
	* 集合对添加的元素类型没有任何限制
	* 集合只知道它盛装的是`Object`，因此取出元素后通常需要进行强制类型转换
* 所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值类型及参数类型。这个类型参数将在使用时（例如，继承或实现这个类或接口，用这个类型声明变量、创建对象时）确定（也称为泛型实参，泛型实参只能是引用数据类型）。
* Java允许在使用构造器或创建匿名内部类时使用菱形语法

## 二、深入泛型

### 1.定义泛型类、接口

* Java允许在定义接口、类时声明泛型形参，泛型形参在整个接口、类体内可当成类型使用。可以为任何类、接口增加泛型声明
* 创建带泛型声明的自定义类时，该类的构造器名还是原来的类名
* <font color=#228B22>不管为泛型类传入哪一种类型实参，它们都被当作同一个类来处理，在内存中只占用一块存储空间，因此在静态变量、静态方法或静态初始化块的声明和初始化中不允许使用泛型形参</font>

### 2.定义泛型类、接口的子类、实现类

* 当创建了带泛型声明的父类、接口后，可以为其定义子类、实现类，此时必须指定泛型实参或者省略泛型
	* 指定泛型实参：子类从父类和接口中继承而来的成员变量、方法都已指定泛型实参
	* 省略泛型：指定泛型实参为`Object`

### 3.定义泛型方法

* 可以定义带泛型声明的方法，方法中定义的泛型只在该方法里使用
* 泛型方法无须显式传入泛型实参，编译器会根据方法实参的泛型实参推断

### 4.类型通配符

* 数组和泛型有所不同，假设A是B的一个子类型（子类或子接口），那么A[]依然是B[]的子类型，但G\<A>不是G\<B>的子类型。A[]自动向上转型为B[]的方式被称为型变，也就是说，数组支持型变，但泛型不支持型变
* 使用类型通配符：为了表示各种泛型类型的父类，可以使用类型通配符，类型通配符是一个`?`，将一个问号作为类型实参传给泛型形参时，它可以匹配任何类型，其类型是`Object`
	* 因为不明确泛型实参，因此不能向带泛型通配符的集合添加对象，只能添加`null`对象。同时，可以使用`get()`方法来返回集合指定索引处的元素，其返回值是个未知类型，但一定是一个`Object`
* 设定上限的类型通配符：指定父类类型的类型通配符，符号是`? extends SuperClass`，将它作为泛型实参传给泛型形参时，它可以匹配任何类型，其类型为`SuperClass`的直接子类或间接子类
	* 因为不明确泛型实参，因此不能向带泛型通配符的集合添加对象，只能添加`null`对象。同时，可以使用`get()`方法来返回集合指定索引处的元素，其返回值是个未知类型，但一定是一个`SuperClass`
	* 假设A是B的一个子类型（子类或子接口），那么G\<A>是G\<? extends B>的子类型，这种型变方式被称为协变
* 设定下限的类型通配符：指定子类类型的类型通配符，符号是`? super SubClass`，将它作为泛型实参传给泛型形参时，它可以匹配任何类型，其类型为`SubClass`的直接父类或间接父类
	* 设定下限类型通配符的集合可以添加元素，添加的元素只能是`SubClass`类或其子类的实例，可以使用`get()`方法来返回集合指定索引处的元素，其返回值是个未知类型，但一定是一个`Object`
	* 假设A是B的一个子类型（子类或子接口），那么G\<B>是G\<? extends A>的子类型，这种型变方式被称为逆变
* 设定泛型形参的上限：Java泛型不仅允许在使用通配符形参时设定上限，也可以在使用泛型形参时设定上限，表示传给该泛型的实际类型要么是该上限类型，要么是其子类

### 5.泛型方法和类型通配符的区别

* <font color=#FF6EB4>如果使用泛型的目的是支持灵活的子类化,那么就使用类型通配符.如果是为了表示方法的一个或多个参数之间的类型依赖关系,或者方法的返回值与参数之间的类型依赖关系,那么就使用泛型方法</font>

## 三、泛型擦除与转换

* <font color=#228B22>当把一个带泛型信息的对象赋给一个没有泛型信息的变量时,所有的泛型信息都会被丢弃,变量类型为泛型上限类型,这称为泛型擦除</font>

