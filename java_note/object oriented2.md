# 面向对象下

## 一、包装类

### 1.基本数据类型的包装类

Java为8种基本数据类型提供了对应的包装类
|基本数据类型|包装类|
|:-:|:-:|
|byte|Byte|
|short|Short|
|int|Integer|
|long|Long|
|float|Float|
|double|Double|
|char|Character|
|boolean|Boolean|

* Java为包装类提供了**自动装箱**和**自动拆箱**的功能：可以把一个基本数据类型变量直接赋给对应的包装类变量或Object类变量，也可以把一个包装类变量直接赋给对应的基本数据类型变量
* 可以利用包装类的parseXxx(String s)静态方法（除了Character类没有该方法）或valueOf(String s)静态方法将字符串转换为基本类型值
* 可以利用String类的valueOf()静态方法将基本数据类型变量转换为字符串
* 包装类变量是引用变量，但是可以直接与基本类型值比较大小。此外，包装类变量之间比较大小只有引用指向同一个对象时才为true
* <font color=green>除了常量池会缓存字符串直接量，系统也存在一个cache数组缓存-128~127之间的所有整数，所以自动装箱后数值相同的Integer变量指向同一个对象</font>

## 二、Object类处理对象的方法

### 1.toString()方法

Object类提供了toString()实例方法，用于表示对象的基本信息，其总是返回该对象实现类的“类名+@+hashCode”值，因此实际使用中需要重写该方法

### 2.==运算符和equals()方法

* ==运算符：用于比较两个基本数据类型变量时，只要数值相等，就返回true，用于比较引用类型变量时，它们指向同一个对象时才返回true，不具有继承关系的变量不能进行比较
* equals()方法：Object类中提供的实例方法，与==运算符没有区别。String类改写了该方法，用于比较字符串对象包含的字符序列是否相同，实际使用中需要重写该方法

<font color=red>注意常量池的问题：ConstantPoolTest.java</font>

## 三、static修饰符

### 1.理解类成员

在Java类中允许包含5中类成员：构造器、初始化块、成员变量、方法、内部类，使用static修饰的成员是类成员，系统底层是通过类来调用类成员的

### 2.单例类

只允许同时存在一个实例的类被称为单例类
单例类构造方法：该类所有构造器使用private修饰，提供一个public static方法用于调用构造器创建对象，提供一个private static成员变量用于缓存该实例
<font color=red>单例类的构造：SingletonTest.java</font>

## 四、final修饰符

final关键字可以修饰类、变量、方法，表示这些类、变量、方法不可改变

### 1.final成员变量

final修饰的成员变量一旦被赋值就不能再改变，因此final修饰的成员变量在定义时就必须显示定义初始值。

* 类成员变量：必须在静态初始化块或声明该变量时指定初始值
* 实例成员变量：必须在非静态初始化块、构造器或声明该变量时指定初始值

### 2.final局部变量

final修饰的局部变量一旦被赋值就不能再改变，而系统不会对局部变量自动执行初始化操作，因此final局部变量要么在声明时指定初始值，要么在后面代码中指定初始值

### 3.final修饰基本类型变量和引用类型变量

* final修饰基本类型变量：该变量一旦指定初始值就不能再改变
* <font color=green>final修饰引用类型变量：final只能保证该变量指向同一个对象，但不能保证该对象不改变</font>

### 4.执行"宏替换"的final变量

<font color=steelblue>对于一个final变量来说，不管是类变量、实例变量或是局部变量，只要在声明该变量时指定了初始值，且该初始值在编译时就能确定下来，那么这个变量相当于一个常量，编译器会将所有用到该变量的地方替换成对应常量</font>

### 5.final方法

final修饰的方法不能被重写，如果希望父类方法不被重写，可以使用final修饰

* 如果final修饰的方法是private方法，子类依然可以定义方法名、形参列表都相同的新方法
* final修饰的方法不能被重写，依然可以被重载

### 6.final类

final修饰的类不能被继承，如果希望一个类不被继承，可以使用final修饰这个类

### 7.不可变类

不可变类是指创建该类的实例后，该实例的实例变量是不可改变的。8个包装类和String类都是不可变类。

* <font color=green>不可变类就是使用final修饰该类的实例变量，但是当final引用变量时，引用的对象是可变的，就会出现问题，此时需要注意构造器的构造方式</font>

### 8.缓存实例的不可变类

如果不可变类的实例被经常使用，那么可以考虑缓存该不可变类的实例，减少系统开销

## 五、abstract修饰符

### 1.抽象方法和抽象类

使用抽象类和抽象方法后，编译时类型变量不需要强制类型转换就能调用运行时类型的方法

* 使用abstract修饰的类和方法称为抽象类和抽象方法，抽象类不能创建实例，抽象方法不能有方法体
* <font color=steelblue>抽象类中不一定有抽象方法，但是含有抽象方法（包括自定义抽象方法、从父类继承抽象方法却没有完全实现、实现一个接口却没有完全实现接口中的抽象方法）的类一定是抽象类</font>
* <font color=steelblue>抽象类可以包含构造器、成员变量、方法、内部类、初始化块，但其构造器不能被new关键字调用以创建实例，主要用于被子类方法调用</font>
* 抽象方法区别于空方法体方法，用分号代替花括号

### 2.抽象类的作用

利用抽象类可以使用模板模式

## 六、接口

### 1.理解接口

接口是从多个相似类中抽象出来的规范，接口不提供任何实现。接口体现的是规范和实现相分离的哲学

### 2.定义接口

定义接口的格式：
>[修饰符] interface 接口名 extends 父接口1,父接口2...{
    //零到多个常量定义...
    //零到多个抽象方法定义...
    //零到多个内部类,接口,枚举定义
    //零到多个私有方法,默认方法或类方法定义...
}

* 修饰符：可以是public或省略
* 接口名：由多个有意义单词连缀而成，每个单词首字母大写，其余字母小写，单词之间没有任何分隔符
* 接口是一种规范，因此接口中不能定义初始化块和构造器，只能定义成员变量、方法、内部类
* <font color=#8E8E38>接口中的成员变量只能是静态常量，必须使用public static final修饰，且必须在声明时指定初始值</font>
* <font color=#FF34B3>接口中的方法可以是类方法、抽象实例方法、默认方法（非抽象实例方法）、私有方法。类方法一定使用public static方法，抽象实例方法一定是public abstract方法，非抽象实例方法一定是public default方法，私有方法一定是private方法。类方法可以直接通过接口来调用，私有方法主要做默认方法和类方法的工具方法，可以是类方法或实例方法</font>
* 接口可以看作一种特殊的类，一个Java源文件种最多只能有一个public接口，且该源文件必须与该public接口同名

### 3.继承接口

接口支持多继承，一个接口可以有多个直接父接口，子接口能够继承父接口的所有静态常量和抽象方法

### 4.使用接口

接口不能创建实例，其主要作用是被实现类实现。接口可以定义引用变量，但只能引用到其实现类的实例上
